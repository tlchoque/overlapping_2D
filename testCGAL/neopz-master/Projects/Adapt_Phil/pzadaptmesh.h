// -*- c++ -*-
// $Id: pzadaptmesh.h,v 1.2 2005-02-28 22:09:57 phil Exp $
/* Generated by Together */

#ifndef TPZADAPTMESH_H
#define TPZADAPTMESH_H

#include "pzcmesh.h"
#include "pzcclonemesh.h"
#include "pzvec.h"

#include <pthread.h>

class TPZInterpolatedElement;
class TPZTransform;
template<class T, class V>
class TPZAvlMap;
class TPZOneDRef;

/// interface to generate adapted meshes
class TPZAdaptMesh {
 public:
  

  /**
   * Simple constructor
   */
  TPZAdaptMesh(TPZCompMesh *mesh);
  
  /**
   * Simple destructor
   */
  ~TPZAdaptMesh();
  
  /**
   * Defines the maximum p order of an element
   */
  void SetMaxP(int maxp);
  
  /**
   * @brief Public interface to get the optmally refined mesh 
   * @param gelstack vector of geometric elements
   * @param porders vector of orders to approximate
   * @param error returns the estimated error
   * @param truerror returns the true error if analitical solution is provided
   * @param ervec estimated element error for original mesh element vector
   * @param f analitical solution
   * @param truervec real element error at each orginal mesh element
   * @param effect error estimator effectivity
   * @param use_trueerror evaluates the error throgh the analitical solution provided by f
   */
  void GetAdaptedMesh(TPZStack<TPZGeoEl *> &gelstack,TPZStack<int> &porders,
		      REAL &error,
		      REAL &truerror,
		      TPZVec<REAL> &ervec, 
		      void (*f)(TPZVec<REAL> &loc,TPZVec<REAL> &val,TPZFMatrix &deriv),
		      TPZVec<REAL> &truervec, 
		      TPZVec<REAL> &effect,
		      int use_trueerror = 0);


  /** @brief Returns the error based on a function pointer which returns the analytic solution */
static REAL ComputeTrueError(TPZInterpolatedElement *coarse, void (*f)(TPZVec<REAL> &loc, TPZVec<REAL> &val, TPZFMatrix &deriv));

  /** @brief multi-threading control variables... */
  static int fThreads_in_use;

 private:
  static int fNClones_to_Analyse;

 protected:
  
  /** @brief Retrieves the geometric reference elements to create the patches */
  void BuildReferenceElements();
  
  /** @brief Builds the patch of all reference elements. The patches are stored into patch vectors */
  void BuildReferencePatch();
  
  /** @brief Return the number of patches */
  int NPatches();
  /** @brief Fill the vector of clone meshes */
  void CreatePatch(int cloneindex);
  
  /** @brief Sorts the elements by the error vector vec, returning permutation vector */
static  void Sort(TPZVec<REAL> &vec, TPZVec<int> &perm);
  
  /** @brief Sort */
static  void HeapSort(TPZVec<REAL> &sol, TPZVec<int> &perm);
  
  /**
   * @brief Sorts the errvec returning the ordering indexes in perm param.
   * @param errvec vector of errors to sort
   * @param perm [out] ordering indexes after sort 
   * @param errpercent is the percentual of the error that must be considered in returning minimum error
   */
static  REAL TPZAdaptMesh::SortMinError (TPZVec<REAL> &errvec, TPZVec<int> &perm, REAL errpercent);

  /**
   * @brief Creates an adpted computational mesh based on original mesh and in a hp refinement pattern also
   * @param mesh: original mesh
   * @param gelstack: h refinement pattern given by a list of an adapted geometric elements
   * @param porders: p refinement pattern for each element of gelstack
   */
public:
static TPZCompMesh* CreateCompMesh (TPZCompMesh *mesh,TPZVec<TPZGeoEl *> &gelstack,TPZVec<int> &porders);
protected:
  /**
   * @brief Verifies if one clone, specified by its index, must be analysed \n
   * This method only be called when the true solution is available and the 
   * option usetrueerror in void  GetAdaptedMesh is set to 1.
   * @param clindex index of the clone to be verified
   * @param minerror minimum error to the clone be analysed
   * @param ervec vector containing the treu error 
   */
  int TPZAdaptMesh::HasLargeError(int clindex, REAL &minerror, TPZVec<REAL> &ervec);


 private:
  /** @brief Delete all elements which have Material Id == -1000 */
  static void RemoveCloneBC(TPZCompMesh *mesh);
  /** @brief Delete the elements in an orderly fashion */
  static void DeleteElements(TPZCompMesh *mesh);
  /**
   * @brief returns a pointer to the element by which the parameter is restrained
   * @param cint element which has restrained connectivities
   * @return the element which contains the unconstrained connectivity
   */
  static TPZInterpolatedElement * LargeElement(TPZInterpolatedElement *cint);
  /** @brief Computational reference mesh */
  TPZCompMesh *fReference;
  
  /** @brief Geometric reference elements vector */
  TPZStack < TPZGeoEl * > fGeoRef;
  
  /** @brief Patches vector */
  TPZStack < TPZGeoEl * > fPatch;
  
  /** @brief Maps the start position of each patch into patches vector */
  TPZStack < int > fPatchIndex;
  
  /** @brief Element error vector */
  TPZStack < REAL > fElementError;

  /** @brief True Element error vector */
  TPZVec < REAL > fTrueErrorVec;
  
  /** @brief This struct groups all information pertinent to a patch of elements */
  struct TPZCloneInfo {  

    /** @brief Clone meshes vector */
    TPZCompCloneMesh * fCloneMesh;

    /** @brief Refined clone meshes */
    TPZCompMesh * fFineCloneMesh;

    /** @brief Contains the element pointers if the element should be refined either in h or p */
    TPZStack<TPZGeoEl *> fRefinedElements;
    /** @brief Contains the order of the refined elements */
    TPZStack<int> fRefinedOrders;

    /** @brief Contains pointers to the original element if it shouldn t be refined */
    TPZStack<TPZGeoEl *> fOriginalElements;
    /** @brief Contains the order of the original element */
    TPZStack<int> fOriginalOrders;

    /** @brief Initializes the data structure */
    TPZCloneInfo();

    /** @brief Deletes the cloned meshes as these are no longer needed */
    void Cleanup();

    /** @brief Will add the refined or original elements depending on the value of minerror to gelstack and orders */
    void AddSelectedElements(TPZVec<REAL> &errvec, REAL minerror,TPZStack<TPZGeoEl *> &gelstack, TPZStack<int> &orders);

    void PrintElementIds(ostream &out);
    /** @brief Deletes all dynamically allocated datastructure */
    ~TPZCloneInfo();
	  
  };

  TPZManVector<TPZCloneInfo> fCloneStructs;

  /** @brief Indexes of the clones that must be analysed */

  TPZStack <int> fClonestoAnalyse;
  /** @brief Delete temporary clone meshes from memory */
  void CleanUp();

  /**
   * @brief Will create a clone mesh and analyse the error of its elements \n
   * Will also delete the temporary data structures created for the analysis
   */
  void ProcessPatch(int clone);

  /** @brief Mesh Error void -- to be used in multi-threading */
  static void  * MeshError (void *t);

  void (*fExact)(TPZVec<REAL> &loc, TPZVec<REAL> &result, TPZFMatrix &deriv);

  /** @brief Maximum p order of an element */
  int fMaxP;

  static  pthread_mutex_t fLock_clindex;
  static  pthread_cond_t fSignal_free;
  
};

#endif
